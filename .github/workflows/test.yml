name: Build and Test Microservices

on:
  push:
    branches: [test]
  pull_request:
    branches: [PROD1]

jobs:

  docker-build-push:
    runs-on: ubuntu-latest  # Use the latest Ubuntu image as the build environment

    steps:
      # Checkout the code
      - name: Checkout code
        uses: actions/checkout@v3
        
      # Log in to Docker Hub
      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}  # Docker Hub username stored in GitHub secrets
          password: ${{ secrets.DOCKERHUB_TOKEN}}  # Docker Hub password stored in GitHub secrets

      # Build and Push Docker images for each service
      - name: Build and Push Docker Images
        run: |
          declare -A services=(
            ["alert-service"]="domains/alert-managment/alert-service"
            ["geo-service"]="domains/alert-managment/geo-service"
            ["schedule-service"]="domains/alert-managment/schedule-service"
            ["template-service"]="domains/alert-managment/template-service"
            ["validation-service"]="domains/alert-managment/validation-service"
            ["role-service"]="domains/core/role-service"
            ["user-service"]="domains/core/user-service"
            ["profile-service"]="domains/core/profile-service"
            ["auth-service"]="domains/core/auth-service"
            ["language-service"]="domains/core/language-service"
            ["logging-service"]="domains/delivery-logging-services/logging-service"
            ["push-service"]="domains/delivery-logging-services/push-service"
            ["sms-service"]="domains/delivery-logging-services/sms-service"
            ["email-service"]="domains/delivery-logging-services/email-service"
            ["retry-service"]="domains/delivery-logging-services/retry-service"
            ["broadcast-service"]="domains/notification/broadcast-service"
            ["channel-service"]="domains/notification/channel-service"
            ["retry-engine"]="domains/notification/retry-engine"
            ["socket-service"]="domains/notification/socket-service"
            ["notification-core"]="domains/notification/notification-core"
            ["graphql-gateway"]="domains/external/graphql-gateway"
            ["soap-consumer"]="domains/external/soap-consumer"
            ["webhook-service"]="domains/external/webhook-service"
            ["external-push"]="domains/external/external-push"
            ["channel-validator"]="domains/external/channel-validator"
            ["stat-analyzer"]="domains/report/stat-analyzer"
            ["metrics-collector"]="domains/report/metrics-collector"
            ["feedback-service"]="domains/report/feedback-service"
            ["report-generator"]="domains/report/report-generator"
            ["audit-trail"]="domains/report/audit-trail"
          )

          for service in "${!services[@]}"; do
            echo "Building image for $service"
            docker build -t darkjus/$service:latest ./${services[$service]}  # Use the correct path to each service directory
            docker push darkjus/$service:latest  # Push the image to Docker Hub
          done

      # Optionally, you can also add a step to verify that the images were pushed
      - name: Verify Docker Images on Docker Hub
        run: |
          for service in "${!services[@]}"; do
            docker pull darkjus/$service:latest  # Pull the image to verify
          done

  test-core:
    runs-on: ubuntu-latest
    continue-on-error: true  # This will allow the job to fail without stopping the pipeline
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_DB: deasla_db
          POSTGRES_USER: deasla_user
          POSTGRES_PASSWORD: deasla_pass
        ports: ['5432:5432']
      mongodb:
        image: mongo:6
        ports: ['27017:27017']
      redis:
        image: redis:7
        ports: ['6379:6379']
      mysql:
        image: mysql:5.7
        env:
          MYSQL_ROOT_PASSWORD: root
          MYSQL_DATABASE: deasla_mysql
          MYSQL_USER: deasla
          MYSQL_PASSWORD: pass
        ports: ['3306:3306']
      neo4j:
        image: neo4j:4.4
        env:
          NEO4J_AUTH: neo4j/test
        ports: ['7474:7474', '7687:7687']
    strategy:
      matrix:
        service: [auth-service, language-service, profile-service, role-service, user-service]
    steps:
      - uses: actions/checkout@v3
      - name: Run tests
        run: |
          cd domains/core/${{ matrix.service }}
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
            pytest tests
          elif [ -f package.json ]; then
            npm install
            npm test
          fi

  test-alert-management:
    runs-on: ubuntu-latest
    continue-on-error: true  # This will allow the job to fail without stopping the pipeline
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_DB: deasla_db
          POSTGRES_USER: deasla_user
          POSTGRES_PASSWORD: deasla_pass
        ports: ['5432:5432']
        options: >-
          --health-cmd="pg_isready"
          --health-interval=10s --health-timeout=5s --health-retries=5
      mongodb:
        image: mongo:6
        ports: ['27017:27017']
      redis:
        image: redis:7
        ports: ['6379:6379']
      mysql:
        image: mysql:5.7
        env:
          MYSQL_ROOT_PASSWORD: root
          MYSQL_DATABASE: deasla_mysql
          MYSQL_USER: deasla
          MYSQL_PASSWORD: pass
        ports: ['3306:3306']
        options: >-
          --health-cmd="mysqladmin ping -h localhost"
          --health-interval=10s --health-timeout=5s --health-retries=5
      neo4j:
        image: neo4j:4.4
        env:
          NEO4J_AUTH: neo4j/test
        ports: ['7474:7474', '7687:7687']
    strategy:
      matrix:
        service: [alert-service, geo-service, schedule-service, template-service, validation-service]
    steps:
      - uses: actions/checkout@v3
      - name: Run tests
        run: |
          cd domains/alert-managment/${{ matrix.service }}
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
            pytest tests
          elif [ -f package.json ]; then
            npm install
            npm test
          fi
          
  # Continue with your other test jobs...
