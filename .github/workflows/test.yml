name: Build and Test Microservices

on:
  push:
    branches: [test]
  pull_request:
    branches: [PROD1]

jobs:

  # Job for building and pushing Docker images
  docker-build-push:
    runs-on: ubuntu-latest  # Use the latest Ubuntu image as the build environment
    
    steps:
      # Checkout the code
      - name: Checkout code
        uses: actions/checkout@v3
        
      # Log in to Docker Hub
      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}  # Docker Hub username stored in GitHub secrets
          password: ${{ secrets.DOCKERHUB_TOKEN}}  # Docker Hub password stored in GitHub secrets

      # Build and Push Docker images for each service
      - name: Build and Push Docker Images
        run: |
          # Define an array with the services and their directories
          declare -A services=( 
            ["alert-service"]="domains/alert-managment"
            ["geo-service"]="domains/alert-managment"
            ["schedule-service"]="domains/alert-managment"
            ["template-service"]="domains/alert-managment"
            ["validation-service"]="domains/alert-managment"
            ["role-service"]="domains/core"
            ["user-service"]="domains/core"
            ["profile-service"]="domains/core"
            ["auth-service"]="domains/core"
            ["language-service"]="domains/core"
            ["logging-service"]="domains/delivery-logging-services"
            ["push-service"]="domains/delivery-logging-services"
            ["sms-service"]="domains/delivery-logging-services"
            ["email-service"]="domains/delivery-logging-services"
            ["retry-service"]="domains/delivery-logging-services"
            ["broadcast-service"]="domains/notification"
            ["channel-service"]="domains/notification"
            ["retry-engine"]="domains/notification"
            ["socket-service"]="domains/notification"
            ["notification-core"]="domains/notification"
            ["graphql-gateway"]="domains/external"
            ["soap-consumer"]="domains/external"
            ["webhook-service"]="domains/external"
            ["external-push"]="domains/external"
            ["channel-validator"]="domains/external"
            ["stat-analyzer"]="domains/report"
            ["metrics-collector"]="domains/report"
            ["feedback-service"]="domains/report"
            ["report-generator"]="domains/report"
            ["audit-trail"]="domains/report"
          )

          # Loop through each service, build and push the Docker image
          for service in "${!services[@]}"; do
            # Build the Docker image for the service
            docker build -t darkjus/$service:latest ./${services[$service]}  # Build using the service's directory as context
            
            # Push the image to Docker Hub
            docker push darkjus/$service:latest
          done

      # Optionally, you can also add a step to verify that the images were pushed
      - name: Verify Docker Images on Docker Hub
        run: |
          for service in "${!services[@]}"; do
            docker pull darkjus/$service:latest  # Pull the image to verify
          done

  # Test jobs (Continue even if some jobs fail)
  test-core:
    runs-on: ubuntu-latest
    continue-on-error: true  # This will allow the job to fail without stopping the pipeline
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_DB: deasla_db
          POSTGRES_USER: deasla_user
          POSTGRES_PASSWORD: deasla_pass
        ports: ['5432:5432']
      mongodb:
        image: mongo:6
        ports: ['27017:27017']
      redis:
        image: redis:7
        ports: ['6379:6379']
      mysql:
        image: mysql:5.7
        env:
          MYSQL_ROOT_PASSWORD: root
          MYSQL_DATABASE: deasla_mysql
          MYSQL_USER: deasla
          MYSQL_PASSWORD: pass
        ports: ['3306:3306']
      neo4j:
        image: neo4j:4.4
        env:
          NEO4J_AUTH: neo4j/test
        ports: ['7474:7474', '7687:7687']
    strategy:
      matrix:
        service: [auth-service, language-service, profile-service, role-service, user-service]
    steps:
      - uses: actions/checkout@v3
      - name: Run tests
        run: |
          cd domains/core/${{ matrix.service }}
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
            pytest tests
          elif [ -f package.json ]; then
            npm install
            npm test
          fi

  # Repeat similar test jobs as needed for other services
  test-alert-management:
    runs-on: ubuntu-latest
    continue-on-error: true  # This will allow the job to fail without stopping the pipeline
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_DB: deasla_db
          POSTGRES_USER: deasla_user
          POSTGRES_PASSWORD: deasla_pass
        ports: ['5432:5432']
        options: >-
          --health-cmd="pg_isready"
          --health-interval=10s --health-timeout=5s --health-retries=5
      mongodb:
        image: mongo:6
        ports: ['27017:27017']
      redis:
        image: redis:7
        ports: ['6379:6379']
      mysql:
        image: mysql:5.7
        env:
          MYSQL_ROOT_PASSWORD: root
          MYSQL_DATABASE: deasla_mysql
          MYSQL_USER: deasla
          MYSQL_PASSWORD: pass
        ports: ['3306:3306']
        options: >-
          --health-cmd="mysqladmin ping -h localhost"
          --health-interval=10s --health-timeout=5s --health-retries=5
      neo4j:
        image: neo4j:4.4
        env:
          NEO4J_AUTH: neo4j/test
        ports: ['7474:7474', '7687:7687']
    strategy:
      matrix:
        service: [alert-service, geo-service, schedule-service, template-service, validation-service]
    steps:
      - uses: actions/checkout@v3
      - name: Run tests
        run: |
          cd domains/alert-managment/${{ matrix.service }}
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
            pytest tests
          elif [ -f package.json ]; then
            npm install
            npm test
          fi
          
  # Continue with your other test jobs...
